for (n in 1:n_MC){
Omega <- create_W(res_MC$list_W[[n]])
M_vect[n] = calcul_M_g_hat_test_sample(res_MC$list_g_hat_on_x[[n]], Omega, n_val, res_MC$list_Y[[n]])
}
return (mean(M_vect))
}
}
library(ggplot2)
plot_mean_true <- function(res_MC, x_evaluation,J){
n_MC = length(res_MC$list_gamma)
n_val = length(res_MC$list_g_hat_on_x[[1]])
#compute the avg
avg <- rep(0, n_val)
for (x in 1:n_val){
for (n in 1:n_MC){
avg[x] <- avg[x] + res_MC$list_g_hat_on_x[[n]][x]/n_MC
}}
data <- data.frame(x_evaluation, avg, g_0_on_x = res_MC$g_0_on_x)
graph <- ggplot(data, aes(x = x_evaluation)) +
geom_line(aes(y = g_0_on_x, colour = 'True Function')) + # Changed the label
geom_line(aes(y = avg, colour = 'Estimate by MC')) + # Changed the label
ylab("Function value") +
xlab("Evaluation points") +
scale_colour_manual(
name = "Functions", # Change this to your desired legend title
values = c("True Function" = "blue", "Estimate by MC" = "red") # Customize colors
) +
ggtitle(paste("True Function vs Estimation (n_MC =", n_MC, ", J =", J, ")"))
return(graph)
}
#### Monte Carlo avec sélection de J ####
MC_CV <- function(method, n_MC, vect_J_to_test, p_train, degree, x_grid, g_0, case, data_param){
list_W <- list()
list_Y <- list()
list_Z <- list()
list_J_opt <- rep(0, n_MC)
list_gamma_opt <- list()
list_g_hat_on_x <- list()
for (n in 1:n_MC){
#generate data
simul <- simulate_data_3(data_param, g_0, case)
W <- simul$W
Y <- simul$Y
Z <- simul$Z
list_W[[n]] <- W
list_Y[[n]] <- Y
list_Z[[n]] <- Z
#compute everything
if (method == 'CV_M'){
res <- optimization_CV_M(Z, W, Y, vect_J_to_test, p_train, degree, x_grid)}
if (method == 'CV_MSE'){
res <- optimization_CV_MSE(Z, W, Y, vect_J_to_test, p_train, degree, x_grid)
}
#compute the optimal J
J_opt <- res$J_opt
list_J_opt[n] <- J_opt
#compute the gamma_J_opt
gamma_hat_J_opt <- res$gamma_hat_j_opt
list_gamma_opt[[n]] <- gamma_hat_J_opt
#compute the function on the grid
g_hat_on_x <- res$g_hat_on_x_opt
list_g_hat_on_x[[n]] <- g_hat_on_x
}
g_0_on_x <- g_0(x_grid, case)
return(list(list_J_opt = list_J_opt, list_gamma = list_gamma_opt,
list_g_hat_on_x = list_g_hat_on_x, g_0_on_x = g_0_on_x,
list_W = list_W, list_Y = list_Y, list_Z = list_Z))
}
MC_lepski_boot <- function(n_MC, n_boot, valid_dim, x_grid, degree, g_0, case, data_param){
list_W <- list()
list_Y <- list()
list_Z <- list()
list_J_opt <- rep(0, n_MC)
list_gamma_opt <- list()
list_g_hat_on_x <- list()
for (n in 1:n_MC){
#generate data
simul <- simulate_data_3(data_param, g_0, case)
W <- simul$W
Y <- simul$Y
Z <- simul$Z
list_W[[n]] <- W
list_Y[[n]] <- Y
list_Z[[n]] <- Z
#compute the optimal J
J_opt <- lepski_bootstrap(n_boot, valid_dim, x_grid, W, Z, Y, degree)
list_J_opt[n] <- J_opt
#compute the gamma_J_opt
gamma_hat_J_opt <- estimation_gamma(J_opt, W, Z, Y, degree)
list_gamma_opt[[n]] <- gamma_hat_J_opt
#compute the function on the grid
basis <- create_dyadic_P_splines(x_grid, Z, J_opt, degree)
g_hat_on_x <- basis%*%gamma_hat_J_opt
list_g_hat_on_x[[n]] <- g_hat_on_x
}
g_0_on_x <- g_0(x_grid, case)
return(list(list_J_opt = list_J_opt, list_gamma = list_gamma_opt,
list_g_hat_on_x = list_g_hat_on_x, g_0_on_x = g_0_on_x,
list_W = list_W, list_Y = list_Y, list_Z = list_Z))
}
MC_lepski <-  function(n_MC, x_eval, degree, valid_dim, g_0, case, data_param){
c_0 = 10
list_W <- list()
list_Y <- list()
list_Z <- list()
list_J_opt <- rep(0, n_MC)
list_gamma_opt <- list()
list_g_hat_on_x <- list()
for (n in 1:n_MC){
#generate data
simul <- simulate_data_3(data_param, g_0, case)
W <- simul$W
Y <- simul$Y
Z <- simul$Z
list_W[[n]] <- W
list_Y[[n]] <- Y
list_Z[[n]] <- Z
#compute the optimal J
J_opt <- lepski_chen(c_0, W, Z, Y, degree, valid_dim)
list_J_opt[n] <- J_opt
#compute the gamma_J_opt
gamma_hat_J_opt <- estimation_gamma(J_opt, W, Z, Y, degree)
list_gamma_opt[[n]] <- gamma_hat_J_opt
#compute the function on the grid
basis <- create_dyadic_P_splines(x_eval, Z, J_opt, degree)
g_hat_on_x <- basis%*%gamma_hat_J_opt
list_g_hat_on_x[[n]] <- g_hat_on_x
}
g_0_on_x <- g_0(x_eval, case)
return(list(list_J_opt = list_J_opt, list_gamma = list_gamma_opt,
list_g_hat_on_x = list_g_hat_on_x, g_0_on_x = g_0_on_x,
list_W = list_W, list_Y = list_Y, list_Z = list_Z))
}
MC_selection <- function(method, n_MC, vect_J_to_test, p_train, degree, x_grid, n_boot, valid_dim, g_0, case, data_param, bool_plot){ #x_grid pour évaluer
if (method == 'CV_M' || method == 'CV_MSE'){
MC_CV_res = MC_CV(method, n_MC, vect_J_to_test, p_train, degree, x_grid, g_0, case, data_param)
if (bool_plot == 1){
plot(plot_mean_true(MC_CV_res, seq(-2, 2, by = 0.1), method))}
return(MC_CV_res)
}
if (method == 'lepski_boot'){
MC_lepski_boot_res = MC_lepski_boot(n_MC, n_boot, valid_dim, x_grid, degree, g_0, case, data_param)
if (bool_plot == 1){
plot(plot_mean_true(MC_lepski_boot_res, seq(-2, 2, by = 0.1), method))}
return(MC_lepski_boot_res)
}
if (method == 'lepski'){
MC_lepski_res = MC_lepski(n_MC, x_grid, degree, valid_dim, g_0, case, data_param)
if (bool_plot == 1){
plot(plot_mean_true(MC_lepski_res, seq(-2, 2, by = 0.1), method))}
return(MC_lepski_res)
}
}
MC_selection('lepski', 10, c(4, 6, 10), 0.5, 3, seq(-2, 2, by=0.1), 1, valid_dim, g_sim_3, 2, c(200, 0.5, 0.9), 1)
MC_selection('lepski_boot', 10, c(4, 6, 10), 0.5, 3, seq(-2, 2, by=0.1), 1, valid_dim, g_sim_3, 2, c(200, 0.5, 0.9), 1)
lepski_bootstrap <- function(n_boot,valid_dim,x_grid, W, Z, Y, degree){#attention : ici x_grid juste pour calculer les sup norm
n = length(Z)
J_max = compute_J_max(W, Z, Y, degree)
print(J_max)
#J_max = 18
I_hat = seq(as.integer(0.1 * (log(J_max)^2))+1, as.integer(J_max), by = 1) #on commence au moins à 2 parce que 1 c'est pas une bonne solution
I_hat = sort(I_hat[sapply(I_hat,valid_dim, degree)]) #select only the valid dimensions
length_I_hat = length(I_hat)
# estimate the models (ie the gamma_J and M_boot for all J)
matrix_gamma = matrix(0, nrow = length_I_hat, ncol = max(I_hat))
list_M_boot <- list()
for (j_index in 1:length_I_hat){
j = I_hat[j_index]
print(j)
M_boot_j <- compute_M_bootstrap(j, W, Z, Y, degree)
list_M_boot[[j_index]] <- M_boot_j
gamma_J <- M_boot_j%*%Y
gamma_J_zeros <- c(gamma_J, rep(0, max(I_hat) - j)) #add zeros for good dimension
matrix_gamma[j_index,] = gamma_J_zeros #ATTENTION ! prendre que les J premiers termes dans les prochains algos pour pas prendre les zéros!!!
}
#draw the w_i
W_boot_matrix <- matrix(rnorm(n_boot * n, mean = 0, sd = 1), nrow = n_boot, ncol = n)
#compute the sigma_J(x) for all values of J and all values of x
matrix_sigma_all_j_all_x <- matrix(0, nrow = length_I_hat, ncol = length(x_grid))
matrix_all_u <- matrix(0, nrow = length_I_hat, ncol = n) #n number of data points (ie length(Z))
for (j_index in 1:length_I_hat){
j = I_hat[j_index]
h_hat_j_on_Z = calcul_hat_g_on_Z(j, Z, matrix_gamma[j_index,1:j], a, b, Z, degree)
u_hat_j = Y - h_hat_j_on_Z
matrix_all_u[j_index,] = u_hat_j
P_j_on_x <- create_dyadic_P_splines(x_grid, Z, j, degree) #create for all x_grid
U_j_j <- create_matrix_U(u_hat_j, u_hat_j)
middle_matrix <- list_M_boot[[j_index]]%*%U_j_j%*%t(list_M_boot[[j_index]]) #ok
vec_sigma_j <- rep(0, length(x_grid))
if (length(middle_matrix)>1){
for (x_index in 1:length(x_grid)){
vec_sigma_j[x_index] <- P_j_on_x[x_index,]%*%(middle_matrix)%*%P_j_on_x[x_index,]
}
}
else{
for (x_index in 1:length(x_grid)){
vec_sigma_j[x_index] = middle_matrix*P_j_on_x[x_index]^{2}
}
}
matrix_sigma_all_j_all_x[j_index,] = vec_sigma_j #ligne j prend les valeurs des sigma_j(x) pour toutes les valeurs de x_grid
}
#compute the sigma_J,J_2(x) for all values of x
matrix_sigma_all_j_j2_all_x <- replicate(length(x_grid), matrix(0, length_I_hat, length_I_hat), simplify = FALSE)
for (j_index in 1:length_I_hat){
j = I_hat[j_index]
P_j_on_x <- create_dyadic_P_splines(x_grid, Z, j, degree)
for (j_prime_index in (j_index):length_I_hat){
j_prime = I_hat[j_prime_index]
#calcul de sigma_j,jprime(x) pour tous les x_grid et ensuite on met dans les matrices
U_j_jp <- create_matrix_U(matrix_all_u[j_index,], matrix_all_u[j_prime_index,])
P_j_prime_on_x <- create_dyadic_P_splines(x_grid, Z,j_prime,degree)
middle_matrix <- list_M_boot[[j_index]]%*%U_j_jp%*%t(list_M_boot[[j_prime_index]])
if (j == 1 && j_prime == 1){
vec_sigma_j_jprime <- rep(0, length(x_grid))
for (x_index in 1:length(x_grid)){
vec_sigma_j_jprime[x_index] = middle_matrix*P_j_on_x[x_index]*P_j_prime_on_x[x_index]
matrix_sigma_all_j_j2_all_x[[x_index]][j_index, j_prime_index] = vec_sigma_j_jprime[x_index]
}
}
if (j == 1 && j_prime >1){
vec_sigma_j_jprime <- rep(0, length(x_grid))
for (x_index in 1:length(x_grid)){
vec_sigma_j_jprime[x_index] = P_j_on_x[x_index]*(middle_matrix%*%P_j_prime_on_x[x_index,])
matrix_sigma_all_j_j2_all_x[[x_index]][j_index, j_prime_index] = vec_sigma_j_jprime[x_index]
}
}
if (j>1 && j_prime == 1){
vec_sigma_j_jprime <- rep(0, length(x_grid))
for (x_index in 1:length(x_grid)){
vec_sigma_j_jprime[x_index] = (P_j_on_x[x_index,]%*%middle_matrix)*P_j_prime_on_x[x_index]
matrix_sigma_all_j_j2_all_x[[x_index]][j_index, j_prime_index] = vec_sigma_j_jprime[x_index]
}
}
if (j>1 && j_prime >1){
vec_sigma_j_jprime <- rep(0, length(x_grid))
for (x_index in 1:length(x_grid)){
vec_sigma_j_jprime[x_index] = P_j_on_x[x_index,]%*%(middle_matrix)%*%P_j_prime_on_x[x_index,]
matrix_sigma_all_j_j2_all_x[[x_index]][j_index, j_prime_index] = vec_sigma_j_jprime[x_index]
}
}
}}
#compute the T stat for each draw of w
T_i = rep(0, n_boot)
for (i in 1:n_boot){
T_i[i] = T_stat_D(x_grid, Y, Z, W, degree, I_hat, W_boot_matrix[i,], list_M_boot, matrix_sigma_all_j_all_x, matrix_all_u, matrix_sigma_all_j_j2_all_x)
}
alpha = min(0.5, sqrt(log(J_max)/J_max))
theta = quantile(T_i, probs = 1 - alpha)
J_n_hat = I_hat[length(I_hat)-1] #on prend l'avant dernier pour être le plus petit strict
J_hat = compute_J_hat(theta,I_hat, x_grid, degree, Z, matrix_gamma, matrix_sigma_all_j_all_x, matrix_sigma_all_j_j2_all_x)
J_tilde = min(J_hat, J_n_hat)
return(J_tilde)
}
MC_selection('lepski_boot', 10, c(4, 6, 10), 0.5, 3, seq(-2, 2, by=0.1), 1, valid_dim, g_sim_3, 2, c(200, 0.5, 0.9), 1)
lepski_bootstrap <- function(n_boot,valid_dim,x_grid, W, Z, Y, degree){#attention : ici x_grid juste pour calculer les sup norm
n = length(Z)
#J_max = compute_J_max(W, Z, Y, degree)
#print(J_max)
J_max = 18
I_hat = seq(as.integer(0.1 * (log(J_max)^2))+1, as.integer(J_max), by = 1) #on commence au moins à 2 parce que 1 c'est pas une bonne solution
I_hat = sort(I_hat[sapply(I_hat,valid_dim, degree)]) #select only the valid dimensions
length_I_hat = length(I_hat)
# estimate the models (ie the gamma_J and M_boot for all J)
matrix_gamma = matrix(0, nrow = length_I_hat, ncol = max(I_hat))
list_M_boot <- list()
for (j_index in 1:length_I_hat){
j = I_hat[j_index]
print(j)
M_boot_j <- compute_M_bootstrap(j, W, Z, Y, degree)
list_M_boot[[j_index]] <- M_boot_j
gamma_J <- M_boot_j%*%Y
gamma_J_zeros <- c(gamma_J, rep(0, max(I_hat) - j)) #add zeros for good dimension
matrix_gamma[j_index,] = gamma_J_zeros #ATTENTION ! prendre que les J premiers termes dans les prochains algos pour pas prendre les zéros!!!
}
#draw the w_i
W_boot_matrix <- matrix(rnorm(n_boot * n, mean = 0, sd = 1), nrow = n_boot, ncol = n)
#compute the sigma_J(x) for all values of J and all values of x
matrix_sigma_all_j_all_x <- matrix(0, nrow = length_I_hat, ncol = length(x_grid))
matrix_all_u <- matrix(0, nrow = length_I_hat, ncol = n) #n number of data points (ie length(Z))
for (j_index in 1:length_I_hat){
j = I_hat[j_index]
h_hat_j_on_Z = calcul_hat_g_on_Z(j, Z, matrix_gamma[j_index,1:j], a, b, Z, degree)
u_hat_j = Y - h_hat_j_on_Z
matrix_all_u[j_index,] = u_hat_j
P_j_on_x <- create_dyadic_P_splines(x_grid, Z, j, degree) #create for all x_grid
U_j_j <- create_matrix_U(u_hat_j, u_hat_j)
middle_matrix <- list_M_boot[[j_index]]%*%U_j_j%*%t(list_M_boot[[j_index]]) #ok
vec_sigma_j <- rep(0, length(x_grid))
if (length(middle_matrix)>1){
for (x_index in 1:length(x_grid)){
vec_sigma_j[x_index] <- P_j_on_x[x_index,]%*%(middle_matrix)%*%P_j_on_x[x_index,]
}
}
else{
for (x_index in 1:length(x_grid)){
vec_sigma_j[x_index] = middle_matrix*P_j_on_x[x_index]^{2}
}
}
matrix_sigma_all_j_all_x[j_index,] = vec_sigma_j #ligne j prend les valeurs des sigma_j(x) pour toutes les valeurs de x_grid
}
#compute the sigma_J,J_2(x) for all values of x
matrix_sigma_all_j_j2_all_x <- replicate(length(x_grid), matrix(0, length_I_hat, length_I_hat), simplify = FALSE)
for (j_index in 1:length_I_hat){
j = I_hat[j_index]
P_j_on_x <- create_dyadic_P_splines(x_grid, Z, j, degree)
for (j_prime_index in (j_index):length_I_hat){
j_prime = I_hat[j_prime_index]
#calcul de sigma_j,jprime(x) pour tous les x_grid et ensuite on met dans les matrices
U_j_jp <- create_matrix_U(matrix_all_u[j_index,], matrix_all_u[j_prime_index,])
P_j_prime_on_x <- create_dyadic_P_splines(x_grid, Z,j_prime,degree)
middle_matrix <- list_M_boot[[j_index]]%*%U_j_jp%*%t(list_M_boot[[j_prime_index]])
if (j == 1 && j_prime == 1){
vec_sigma_j_jprime <- rep(0, length(x_grid))
for (x_index in 1:length(x_grid)){
vec_sigma_j_jprime[x_index] = middle_matrix*P_j_on_x[x_index]*P_j_prime_on_x[x_index]
matrix_sigma_all_j_j2_all_x[[x_index]][j_index, j_prime_index] = vec_sigma_j_jprime[x_index]
}
}
if (j == 1 && j_prime >1){
vec_sigma_j_jprime <- rep(0, length(x_grid))
for (x_index in 1:length(x_grid)){
vec_sigma_j_jprime[x_index] = P_j_on_x[x_index]*(middle_matrix%*%P_j_prime_on_x[x_index,])
matrix_sigma_all_j_j2_all_x[[x_index]][j_index, j_prime_index] = vec_sigma_j_jprime[x_index]
}
}
if (j>1 && j_prime == 1){
vec_sigma_j_jprime <- rep(0, length(x_grid))
for (x_index in 1:length(x_grid)){
vec_sigma_j_jprime[x_index] = (P_j_on_x[x_index,]%*%middle_matrix)*P_j_prime_on_x[x_index]
matrix_sigma_all_j_j2_all_x[[x_index]][j_index, j_prime_index] = vec_sigma_j_jprime[x_index]
}
}
if (j>1 && j_prime >1){
vec_sigma_j_jprime <- rep(0, length(x_grid))
for (x_index in 1:length(x_grid)){
vec_sigma_j_jprime[x_index] = P_j_on_x[x_index,]%*%(middle_matrix)%*%P_j_prime_on_x[x_index,]
matrix_sigma_all_j_j2_all_x[[x_index]][j_index, j_prime_index] = vec_sigma_j_jprime[x_index]
}
}
}}
#compute the T stat for each draw of w
T_i = rep(0, n_boot)
for (i in 1:n_boot){
T_i[i] = T_stat_D(x_grid, Y, Z, W, degree, I_hat, W_boot_matrix[i,], list_M_boot, matrix_sigma_all_j_all_x, matrix_all_u, matrix_sigma_all_j_j2_all_x)
}
alpha = min(0.5, sqrt(log(J_max)/J_max))
theta = quantile(T_i, probs = 1 - alpha)
J_n_hat = I_hat[length(I_hat)-1] #on prend l'avant dernier pour être le plus petit strict
J_hat = compute_J_hat(theta,I_hat, x_grid, degree, Z, matrix_gamma, matrix_sigma_all_j_all_x, matrix_sigma_all_j_j2_all_x)
J_tilde = min(J_hat, J_n_hat)
return(J_tilde)
}
MC_selection('lepski_boot', 10, c(4, 6, 10), 0.5, 3, seq(-2, 2, by=0.1), 1, valid_dim, g_sim_3, 2, c(200, 0.5, 0.9), 1)
compute_J_max(simul$W, simul$Z, simul$Y, degree)
compute_J_max(simul$W, simul$Z, simul$Y, 3)
simul <- simulate_data_3(c(200, 0.5, 0.9), g_sim_3, 2)
#tests
for (n in 1:10){
simul <- simulate_data_3(c(200, 0.5, 0.9), g_sim_3, 2)
J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(200, 0.5, 0.9), g_sim_3, 2)
J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(200, 0.5, 0.9), g_sim_3, 2)
J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(200, 0.5, 0.9), g_sim_3, 2)
J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(200, 0.5, 0.9), g_sim_3, 2)
J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(200, 0.5, 0.9), g_sim_3, 2)
J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(200, 0.5, 0.9), g_sim_3, 2)
J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(200, 0.5, 0.9), g_sim_3, 2)
#J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
J_test <- 10
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(400, 0.5, 0.9), g_sim_3, 2)
J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
#J_test <- 10
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(400, 0.5, 0.9), g_sim_3, 2)
J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
#J_test <- 10
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(400, 0.5, 0.9), g_sim_3, 2)
J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
#J_test <- 10
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(400, 0.5, 0.9), g_sim_3, 2)
J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
#J_test <- 10
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(400, 0.5, 0.9), g_sim_3, 2)
#J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
J_test <- 10
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(400, 0.5, 0.9), g_sim_3, 2)
#J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
J_test <- 18
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(400, 0.5, 0.9), g_sim_3, 2)
#J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
J_test <- 18
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(400, 0.5, 0.9), g_sim_3, 2)
#J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
J_test <- 18
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
#tests
for (n in 1:10){
print(n)
simul <- simulate_data_3(c(400, 0.5, 0.9), g_sim_3, 2)
J_test <- compute_J_max(simul$W, simul$Z, simul$Y, 3)
print(J_test)
J_test <- 18
gamma_test <- estimation_gamma(J_test, simul$W, simul$Z, simul$Y, 3)
}
data_param = c(200, 0.5, 0.9)
n_MC = 2000
data_param = c(200, 0.5, 0.9)
n_MC = 2000
J = 4
degree = 3
x_evaluation = seq(-2, 2, length.out = 100)
data_param = c(200, 0.5, 0.9)
n_MC = 2000
J = 4
degree = 3
x_evaluation = seq(-2, 2, length.out = 100)
MC_J4_n200_deg3_rhocase1_gcase2 <- MC_fixed_J(J, n_MC, degree, x_evaluation, g_sim_3, 2, data_param)
MC_J4_n200_deg3_rhocase1_gcase2
perf_MC_J4_n200_deg3_rhocase1_gcase2 <- rep(0, 5)
perf_MC_J4_n200_deg3_rhocase1_gcase2[1] = compute_perf(MC_J4_n200_deg3_rhocase1_gcase2, 'M')
perf_MC_J4_n200_deg3_rhocase1_gcase2[2] = compute_perf(MC_J4_n200_deg3_rhocase1_gcase2, 'supnorm')
perf_MC_J4_n200_deg3_rhocase1_gcase2[3] = compute_perf(MC_J4_n200_deg3_rhocase1_gcase2, 'Var')
perf_MC_J4_n200_deg3_rhocase1_gcase2[4] = compute_perf(MC_J4_n200_deg3_rhocase1_gcase2, 'MSE')
perf_MC_J4_n200_deg3_rhocase1_gcase2[5] = compute_perf(MC_J4_n200_deg3_rhocase1_gcase2, 'bias')
perf_MC_J4_n200_deg3_rhocase1_gcase2
save.image(file = "perf_MC_J4_n200_deg3_rhocase1_gcase2.RData")
save.image(file = ".RData")
save.image(file = "C:/Users/candi/Desktop/ETUDES/2025 - ENSAE 4A - EPFL3A/pdm/code/github/perf_MC_J4_n200_deg3_rhocase1_gcase2.RData")
source("code_b_splines_monte_carlo.R")
setwd("C:/Users/candi/Desktop/ETUDES/2025 - ENSAE 4A - EPFL3A/pdm/code/github/master_thesis")
source("code_b_splines_monte_carlo.R")
